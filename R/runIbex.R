#' Main Ibex interface
#' 
#' Use this to run the Ibex algorithm to return latent vectors in 
#' the form of a matrix or if you prefer.
#' 
#' @examples
#'ibex_values <- Ibex.matrix(ibex_example, 
#'                         chains = "Heavy",
#'                         AA.properties = "AF")
#'                         
#' @param sc Single Cell Object in Seurat or SingleCell Experiment format
#' @param chains Heavy or Light
#' @param AA.properties Amino acid properties to use for distance calculation: 
#' "AF" = Atchley factors, "KF" = Kidera factors, "both" = AF and KF, or "OHE" for
#' One Hot Autoencoder
#' 
#' @export
#' @importFrom SeuratObject CreateDimReducObject
#' 
#' @return Ibex encoded values from the autoencoder
Ibex.matrix <- function(sc, 
                    chains = "Heavy", 
                    AA.properties = "AF") {
    BCR <- getBCR(sc, chains)
    if (AA.properties %in% c("AF", "KF", "both", "all", "OHE")) {
        print("Calculating the Amino Acid Properties...")
        reduction <- aaProperty(BCR, AA.properties)
    }
    return(reduction)
}

#' Ibex single cell calculation
#'
#'Run Ibex algorithm with Seurat or SingleCellExperiment pipelines
#'
#' @examples
#' ibex_example <- runIbex(ibex_example, 
#'                         AA.properties = "AF", 
#'                         reduction.name = "Ibex.AF")
#'                         
#' @param sc Single Cell Object in Seurat or SingleCell Experiment format
#' @param chains Heavy or Light
#' @param AA.properties  Amino acid properties to use for distance calculation: 
#' "AF" = Atchley factors, "KF" = Kidera factors, "both" = AF and KF, or "OHE" for
#' One Hot Autoencoder
#' @param reduction.name Keyword to save Ibex reduction. Useful if you want
#' to try Ibex with multiple parameters 
#' @export
#' @return Seurat or SingleCellExperiment object with Ibex dimensions placed 
#' into the dimensional reduction slot. 
#' 
runIbex <- function(sc, 
                    chains = "Heavy", 
                    AA.properties = "AF",
                    reduction.name = "Ibex") {

    cells.chains <- rownames(sc[[]][!is.na(sc[["CTaa"]]),])
    sc <- subset(sc, cells = cells.chains)
    reduction <- Ibex.matrix(sc,
                        chains, 
                        AA.properties)
    BCR <- getBCR(sc, chains)
    sc <- adding.DR(sc, reduction, reduction.name)
    return(sc)
}

#' Remove BCR genes from variable gene results
#'
#'Most single-cell workflows use highly-expressed and highly-variable
#'genes for the initial calculation of PCA and subsequent dimensional
#'reduction. This function will remove the BCR genes from the variable
#'features in the Seurat object or from a vector generated by
#'the Bioconductor scran workflow. 
#'
#' @examples
#' x <- quietBCRgenes(ibex_example)
#' 
#' @param sc Single-cell object in Seurat format or vector of variable genes to use in reduction
#' @param assay The Seurat assay slot to use to remove BCR genes from, NULL value will default to
#' the default assay
#' @importFrom SeuratObject DefaultAssay
#' @export
#' @return Seurat object or vector list with BCR genes removed.
quietBCRgenes <- function(sc, 
                          assay = NULL) {
    unwanted_genes <- "^IG[HLK][VDJ]"
    if (inherits(x=sc, what ="Seurat")) {
        if (is.null(assay)) {
            assay <- DefaultAssay(sc)
        }
        unwanted_genes <- grep(pattern = unwanted_genes, x = sc[[assay]]@var.features, value = TRUE)
        sc[[assay]]@var.features <- sc[[assay]]@var.features[sc[[assay]]@var.features %!in% unwanted_genes]
    } else {
        #Bioconductor scran pipelines uses vector of variable genes for DR
        unwanted_genes <- grep(pattern = unwanted_genes, x = sc, value = TRUE)
        sc <- sc[sc %!in% unwanted_genes]
    }
    return(sc)
}

#' Cluster clones using the Ibex dimensional reductions
#' 
#' Use this to return clusters for clonotypes based on 
#' the \link[bluster]{bluster} clustering parameters.
#' 
#' @examples
#' \dontrun{
#' sc <- clonalCommunity(sc, 
#'                       reduction.name = NULL, 
#'                       cluster.parameter = KNNGraphParam())
#' }
#' @param sc Single Cell Object in Seurat or SingleCell Experiment format. In addition, the outputs of distReduction()
#' and aaReduction() can be used.
#' @param reduction.name Name of the dimensional reduction output from runIbex()
#' @param cluster.parameter The community detection algorithm in \link[bluster]{bluster}
#' @param ... For the generic, further arguments to pass to specific methods.
#' @importFrom bluster clusterRows NNGraphParam HclustParam KmeansParam KNNGraphParam PamParam SNNGraphParam SomParam DbscanParam
#' @importFrom igraph simplify spectrum graph_from_edgelist E `E<-`
#' @importFrom SingleCellExperiment reducedDim
#' @export
#' @return Single-Cell Object with ibex.clusters in the meta.data
clonalCommunity <- function(sc, 
                            reduction.name = NULL, 
                            cluster.parameter=KNNGraphParam(k=30, ...), 
                            ...) {
    if (inherits(x=sc, what ="Seurat")) { 
        dim.red <- sc[[reduction.name]] 
        dim.red <- dim.red@cell.embeddings
    } else if (inherits(x=sc, what ="SingleCellExperiment")){
        dim.red <- reducedDim(sc, reduction.name)
    } else {
        if(inherits(x=sc, what ="dist")) {
            mat <- sc
            #mat[is.na(mat)] <- 0
            dimension <- attr(mat, "Size")
            edge <- NULL
            for (j in seq_len(dimension)[-1]) {
                row <- dist.convert(mat,j)
                tmp.edge <- data.frame("from" = j, "to" = seq_len(j)[-j], weight = row)
                edge <- rbind(edge, tmp.edge)
            }
            edge <- na.omit(edge)
            g <- graph.edgelist(as.matrix(edge[,c(1,2)]), directed = FALSE)
            E(g)$weights <- edge$weight
            g <- simplify(g)
            eigen <- spectrum(g, 
                              which = list(howmany = 30), 
                              algorithm = "arpack")
            dim.red <- eigen$vectors
        } else {
            dim.red <- sc
        }
    }
    clusters <- suppressWarnings(clusterRows(dim.red, BLUSPARAM=cluster.parameter))
    clus.df <- data.frame("ibex.clusters" = paste0("ibex.", clusters))
    if (inherits(x=sc, what ="Seurat") | inherits(x=sc, what ="SingleCellExperiment")) {
        rownames(clus.df) <- rownames(dim.red)
        sc <- add.meta.data(sc, clus.df, colnames(clus.df))
        return(sc)
    } 
    return(clus.df)
    
}
