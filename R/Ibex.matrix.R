#' Ibex Matrix Interface
#'
#' This function runs the Ibex algorithm to generate latent vectors from input data.
#' The output can be returned as a matrix, with options to choose between deep learning 
#' autoencoders or geometric transformations based on the BLOSUM62 matrix.
#'
#' @examples
#' # Using the encoder method with a variational autoencoder
#' ibex_values <- Ibex.matrix(ibex_example, 
#'                            chain = "Heavy",
#'                            method = "encoder",
#'                            encoder.model = "VAE",
#'                            encoder.input = "atchleyFactors")
#'
#' # Using the geometric method with a specified angle
#' ibex_values <- Ibex.matrix(ibex_example, 
#'                            chain = "Heavy",
#'                            method = "geometric",
#'                            geometric.theta = pi)
#'
#' @param input.data Input data, which can be:
#'   \itemize{
#'     \item A Single Cell Object in Seurat or SingleCellExperiment format
#'     \item The output of \code{combineBCR()} from the \code{scRepertoire} package
#'   }
#' @param chain Character. Specifies which chain to analyze:
#'   \itemize{
#'     \item "Heavy" for the heavy chain
#'     \item "Light" for the light chain
#'   }
#' @param method Character. The algorithm to use for generating latent vectors:
#'   \itemize{
#'     \item "encoder" - Uses deep learning autoencoders
#'     \item "geometric" - Uses geometric transformations based on the BLOSUM62 matrix
#'   }
#' @param encoder.model Character. The type of autoencoder model to use:
#'   \itemize{
#'     \item "CNN" - Convolutional Neural Network-based autoencoder
#'     \item "VAE" - Variational Autoencoder
#'   }
#' @param encoder.input Character. Specifies the input features for the encoder model. Options include:
#'   \itemize{
#'     \item Amino Acid Properties: "atchleyFactors", "crucianiProperties", "FASGAI", "kideraFactors", "MSWHIM", "ProtFP", "stScales", "tScales", "VHSE", "zScales"
#'     \item "OHE" for One Hot Encoding (mandatory for biLSTM models)
#'   }
#' @param geometric.theta Numeric. Angle (in radians) for the geometric transformation. Only used when \code{method = "geometric"}.
#'
#' @return A matrix of latent vectors generated by the specified method.
#'
#' @export
#' @importFrom SeuratObject CreateDimReducObject
#' @importFrom immApex propertyEncoder onehotEncoder geometricEncoder getIR
#'
#' @seealso 
#' \code{\link[immApex]{propertyEncoder}}, 
#' \code{\link[immApex]{geometricEncoder}}
Ibex.matrix <- function(input.data, 
                        chain = "Heavy", 
                        method = "encoder",
                        encoder.model = "VAE", 
                        encoder.input = "atchleyFactors",
                        geometric.theta = pi/3) {
  #Chain Check
  if(chain %!in% c("Heavy", "Light")) {
    stop("Please select one of the following chains: 'Heavy', 'Light'")
  }
  
  #Model Check
  if(method == "encoder") {
    valid.encoder.inputs <- c("atchleyFactors", "crucianiProperties", "kideraFactors", "MSWHIM", "tScales", "OHE")
    if(encoder.input %!in% valid.encoder.inputs) {
      stop("Please select one of the valid encoder inputs.")
    }
  }
  
  #Will be used to filter output of getIR()
  loci <- ifelse(chain == "Heavy", "IGH", c("IGK", "IGL"))
  expanded.sequences <- grepl(".Exp", encoder.model)
  
  #Set Dictionary for embedding
  if(expanded.sequences) {
    dictionary <- c(amino.acids, "_")
  } else {
    dictionary <- amino.acids
  }
  
  #Getting Sequences
  BCR <- getIR(input.data, chain, sequence.type = "aa")[[1]]
  
  #Filtering out NA values 
  if(any(is.na(BCR[,2]))) {
    BCR <- BCR[-which(is.na(BCR[,2])),]
  }
  #Filtering out sequences that do not match gene locid
  if(any(!grep(paste0(loci, collapse = "|"), BCR[,"v"]))) {
    BCR <- BCR[-!grep(paste0(loci, collapse = "|"), BCR[,"v"]),]
  }
  
  #Checking Sequences - needs to be < 45 or 90
  checkLength(x = BCR[,2], expanded = expanded.sequences)
  length.to.use <- ifelse(expanded.sequences, 90, 45)
  
  
  if (method == "encoder") {
    print("Encoding Sequences...")
    
    if(encoder.input == "OHE") {
      encoded.values <- suppressMessages(onehotEncoder(BCR[,2],
                                                       max.length = length.to.use,
                                                       convert.to.matrix = TRUE,
                                                       sequence.dictionary = dictionary,
                                                       padding.symbol = "."))
    } else {
      encoded.values <- suppressMessages(propertyEncoder(BCR[,2], 
                                                         max.length = length.to.use,
                                                         method.to.use = encoder.input,
                                                         convert.to.matrix = TRUE))
    }
    print("Calculating Latent Dimensions...")
    #Getting Model
    aa.model <- aa.model.loader(species = "Human", chain, encoder.input, encoder.model)
    reduction <- stats::predict(aa.model, encoded.values, verbose = 0)
  } else if (method == "geometric") {
    print("Performing geometric transformation...")
    reduction <- suppressMessages(geometricEncoder(BCR[,2], theta = geometric.theta))
    reduction <- cbind(BCR[,1], reduction)
  }
  #TODO Check the barcode usage here
  reduction <- as.data.frame(reduction)
  barcodes <- reduction[,1]
  reduction <- reduction[,-1]
  rownames(reduction) <- barcodes
  colnames(reduction) <- paste0("Ibex_", seq_len(ncol(reduction)))
  return(reduction)
}